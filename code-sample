### Project Structure
```
project/
├── app/
│   ├── __init__.py
│   ├── models.py         # SQLAlchemy ORM models
│   ├── schemas.py        # Pydantic models
│   ├── database.py       # DB session and engine
│   └── main.py           # FastAPI app
└── alembic/
    ├── env.py            # Alembic environment
    ├── script.py.mako
    └── versions/
        └── xxxx_initial.py  # Initial migration
```

---

# app/database.py
```python
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
import os

DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///./test.db")

engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()
```  

---

# app/models.py  
```python
from sqlalchemy import Column, String, Boolean, Integer, Date, ForeignKey, Enum, Float
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
import uuid
import enum
from .database import Base

class RoleEnum(enum.Enum):
    admin = "admin"
    user = "user"

class Role(Base):
    __tablename__ = "roles"
    id = Column(Integer, primary_key=True, index=True)
    name = Column(Enum(RoleEnum), unique=True, nullable=False)
    description = Column(String, nullable=True)
    users = relationship("User", back_populates="role")

class User(Base):
    __tablename__ = "users"
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = Column(String, nullable=False)
    phone = Column(String, unique=True, index=True, nullable=False)
    email = Column(String, unique=True, index=True, nullable=True)
    gender = Column(String, nullable=True)
    date_of_birth = Column(Date, nullable=True)
    place = Column(String, nullable=True)
    role_id = Column(Integer, ForeignKey("roles.id"), nullable=False)
    is_active = Column(Boolean, default=True)
    last_login_at = Column(Date, nullable=True)

    role = relationship("Role", back_populates="users")
    records = relationship("Record", back_populates="user")

class Category(Base):
    __tablename__ = "categories"
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    name = Column(String, unique=True, nullable=False)
    title = Column(String, nullable=False)
    description = Column(String, nullable=True)
    published = Column(Boolean, default=False)
    rank = Column(Integer, default=0)

    records = relationship("Record", back_populates="category")

class MediaType(enum.Enum):
    text = "text"
    audio = "audio"
    video = "video"
    image = "image"

class Record(Base):
    __tablename__ = "records"
    uid = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    type = Column(Enum(MediaType), nullable=False)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    category_id = Column(UUID(as_uuid=True), ForeignKey("categories.id"), nullable=False)
    geo_lat = Column(Float, nullable=True)
    geo_lng = Column(Float, nullable=True)
    storage_path = Column(String, nullable=True)
    status = Column(String, default="pending")  # pending/uploaded/failed

    user = relationship("User", back_populates="records")
    category = relationship("Category", back_populates="records")
```  

---

# app/schemas.py  
```python
from pydantic import BaseModel, EmailStr, Field
from uuid import UUID
from datetime import date
from enum import Enum

class RoleEnum(str, Enum):
    admin = "admin"
    user = "user"

# Base user schema
class UserBase(BaseModel):
    phone: str = Field(..., example="+919876543210")
    name: str
    email: EmailStr | None
    gender: str | None
    date_of_birth: date | None
    place: str | None

# properties to receive on user creation
class UserCreate(UserBase):
    role: RoleEnum = Field(default=RoleEnum.user)

# properties to return to client
class UserRead(UserBase):
    id: UUID
    role: RoleEnum
    is_active: bool
    last_login_at: date | None

    class Config:
        orm_mode = True

class CategoryBase(BaseModel):
    name: str
    title: str
    description: str | None = None
    published: bool = False
    rank: int = 0

class CategoryCreate(CategoryBase):
    pass

class CategoryRead(CategoryBase):
    id: UUID
    class Config:
        orm_mode = True

class MediaType(str, Enum):
    text = "text"
    audio = "audio"
    video = "video"
    image = "image"

class RecordBase(BaseModel):
    type: MediaType
    user_id: UUID
    category_id: UUID
    geo_lat: float | None
    geo_lng: float | None

class RecordCreate(RecordBase):
    pass

class RecordRead(RecordBase):
    uid: UUID
    storage_path: str | None
    status: str

    class Config:
        orm_mode = True
```  

---

# Alembic Configuration

1. **Initialize Alembic**
```bash
alembic init alembic
```

2. **alembic/env.py** — integrate SQLAlchemy metadata
```python
from logging.config import fileConfig
from sqlalchemy import engine_from_config, pool
from alembic import context
import os, sys
sys.path.append(os.path.abspath(os.path.join(os.getcwd(), "app")))
from database import DATABASE_URL, Base

target_metadata = Base.metadata

config = context.config
fileConfig(config.config_file_name)
config.set_main_option('sqlalchemy.url', DATABASE_URL)

def run_migrations_offline():
    url = config.get_main_option("sqlalchemy.url")
    context.configure(url=url, target_metadata=target_metadata, literal_binds=True)
    with context.begin_transaction():
        context.run_migrations()

def run_migrations_online():
    connectable = engine_from_config(
        config.get_section(config.config_ini_section),
        prefix='sqlalchemy.',
        poolclass=pool.NullPool,
    )
    with connectable.connect() as connection:
        context.configure(connection=connection, target_metadata=target_metadata)
        with context.begin_transaction():
            context.run_migrations()

if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
```  

3. **Create Initial Migration**
```bash
alembic revision --autogenerate -m "initial schema"
alembic upgrade head
```

This setup uses Pydantic for request/response validation, SQLAlchemy ORM for model definitions, and Alembic for schema migrations. You can now iteratively update models and run `alembic revision --autogenerate` to keep your database in sync.

